/* 
 * operator.h
 * --------
 * An Operator object is a representation of a quantum mechanical operator.
 * An Operator is a unitary operation on a State of n qubits that converts
 * it to a new state on those same n qubits.
 * In the context of an n-qubit quantum computer, these operators represent
 * gates in a quantum circuit.
 * 
 * Many standard Operators can by generated by calling one of the provided
 * constructors: CNot, CPhase, Swap, Pauli gates, Hadamard, Phase gates, etc.
 * 
 * An Operator can be applied to a State by using the apply() function,
 * which produces a new n-qubit State.
 * 
 * In addition, the Operator module supports combining existing gates to form
 * new gates. This includes operations such as Operator composition, tensor
 * products of Operators, and producing controlled gates.
 * 
 * Author: Barak Nehoran
 * Advisor: Iasonas Petras
 */

#ifndef OPERATOR_H
#define OPERATOR_H

#include "pair.h"
#include "state.h"
#include "register.h"
#include <stdlib.h>
#include <assert.h>
#include <complex.h>

typedef struct OperatorStruct* Operator;

/* a string representation of the Operator */
char* Operator_toString (Operator op);

/*
 * Standard Gates / Constructors
 */

/* Returns a controlled not (CNOT) Operator with multiple controls and targets 
   on n qubits that controls from each of the qubits in controls 
   and flips each of the qubits in targets.
   Both controls and targets must be arrays terminated by a -1. */
Operator Operator_cnot (int n, int* controls, int* targets);

/* Returns a controlled not (CNOT) Operator with multiple controls and targets 
   on n qubits that flips each bit specified in targets if 
   (a) every bit specified in controls_1 is a 1 and 
   (b) every bit specidied in controls_0 is a 0.
   All three arrays must be terminated by a -1. */
Operator Operator_cnot_0 (int n, int* controls_1, int* controls_0, 
      int* targets);

/* Returns a controlled phase Operator on n qubits
   that controls from each of the qubits in controls
   (negates the amplitude whenever all controls are 1) */
Operator Operator_cphase (int n, int* controls);

/* Returns the n-qubit Operator which swaps qubits j and k */
Operator Operator_swap (int n, int j, int k);

/* the X, Y, and Z, Pauli spin Operators on qubit k */
Operator Operator_pauli_X (int n, int k);
Operator Operator_pauli_Y (int n, int k);
Operator Operator_pauli_Z (int n, int k);

/* the single-qubit hadamard Operator on qubit k */
Operator Operator_hadamard (int n, int k);

/* The pi/4 phase gate (phase_S^2 = pauli_Z) on qubit k */
Operator Operator_phase_S (int n, int k);

/* The pi/8 phase gate (phase_T^2 = phase_S) on qubit k */
Operator Operator_phase_T (int n, int k);

/* An arbitrary rotation on the spin of qubit k
   Rotates the spin around the axis (ax,ay,az) by
   amount angle in radians */
Operator Operator_rot (int n, int k, double ax, double ay, double az, 
      double angle);

/* Returns an operator that performs the addition and multiplication
   of Registers of qubits. 
   Specificically, the operator takes an n-qubit state with three Registers: 
      |x>, |y>, and |z>
   where |x> has xn := (x->high - x->low) qubits of which 
   xm := (x->high - x->zero) represent the integer part, leaving 
   (x->zero - z->low) to represent the fractional part,
   and where the qubit representing bit 2^0 of x is qubit number x->zero. 
   The |y> and |z> registers are represented likewise.
   The result is the product of the numbers represented by |x> and |y> 
   plus the number represented by |z>, and is stored in the |z> register.
   That is, the calculation performed is 
      z = x*y + z
   In order to allow enough room to store the result, 
   zm must be at least xm + ym + 1, and zn must be at least xn + yn + 1,
   with an extra (most significant) qubit to store the carry bit 
   (otherwise overflow can occur). */
Operator Operator_multiply_add(int n, Register x, Register y, Register z);

/* Returns an operator that performs the subtraction and multiplication
   of Registers of qubits. 
   Specificically, the operator takes an n-qubit state with three Registers: 
      |x>, |y>, and |z>
   where |x> has xn := (x->high - x->low) qubits of which 
   xm := (x->high - x->zero) represent the integer part, leaving 
   (x->zero - z->low) to represent the fractional part,
   and where the qubit representing bit 2^0 of x is qubit number x->zero. 
   The |y> and |z> registers are represented likewise.
   The result is the product of the numbers represented by |x> and |y> 
   subtracted from the number represented by |z>, and is stored in the |z> 
   register. That is, the calculation performed is 
      z = z - x*y
   In order to allow enough room to store the result, 
   zm must be at least xm + ym + 1, and zn must be at least xn + yn + 1,
   with an extra (most significant) qubit to store the carry bit 
   (otherwise overflow can occur). */
Operator Operator_multiply_subtract_from(int n, 
      Register x, Register y, Register z);

/* Frees the operator op. */
void Operator_free(Operator op);


/* Returns whether the given Operator is unitary */
bool Operator_is_unitary (Operator op);

/* Returns whether the given Operator is hermitian */
bool Operator_is_hermitian (Operator op);

/* Returns the hermitian conjugate of the Operator op */
Operator Operator_dagger (Operator op);

/* Takes an n-qubit state |s> and returns the n-qubit state
   that is the result of applying the Operator to |s> */
State Operator_apply (Operator op, State s);

/* Same as apply but prints out verbose results. 
   Useful for debugging. */
State Operator_print_apply(Operator op, State s);

/* Returns an Operator that is the result of taking the
   tensor product of all the Operators in op */
Operator Operator_tensor (Operator* ops);

/* Returns the Operator that is the same as applying each
   of the Operators in ops in sequence.
   The argument ops must be a null-terminated array of Operators.
   Destroys each of the argument operators. */
Operator Operator_compose (Operator* ops);

/* Returns the Operator that is the same as applying each
   of the two Operators.
   Destroys the two argument operators. */
Operator Operator_compose2 (Operator op1, Operator op2);

/* Takes a single-qubit (2 by 2) Operator op and converts it to
   a controlled Operator on n qubits with the given control
   and target qubits */
Operator Operator_controlled (Operator op, int n, int control, int target);

/* Takes an Operator op and converts it to
   a controlled Operator on n qubits with the given control qubits */
Operator Operator_controlled2 (Operator op, int n, int* controls);

/* Runs the unit testing code. Except when preblems arise, running 
   this function should produce no visible effect. */
void Operator_run_tests(int n);


#endif