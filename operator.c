/* 
 * operator.c
 * --------
 * An Operator object is a reprsentation of a quantum mechanical operator.
 * An Operator is a unitary operation on a State of n qubits that converts
 * it to a new state on those same n qubits.
 * In the context of an n-qubit quantum computer, these operators represent
 * gates in a quantum circuit.
 * Operators are represented by a one of 
 * (a) a (pointer to a) one-to-one function mapping basis states to other 
 *    basis states.
 * (b) a one-to-many function mapping basis states to sets of other 
 *    basis states.
 * (c) a 2^k-by-2^k matrix representing the Operator's effect on k of the 
 *    n qubits in a state.
 *    (Option c performs very slowly for all but small values of k, but allows
 *    the creation of arbitrary Operators by specifying their defining matrix.)
 * as well as arrays of positive integers representing the qubits acting as the 
 * controls and targets of the gate (whenever relevant).
 *
 * Many standard Operators can by generated by calling one of the provided
 * constructors: CNot, CPhase, Swap, Pauli gates, Hadamard, Phase gates, etc.
 * 
 * An Operator can be applied to a State by using the apply() function,
 * which produces a new n-qubit State.
 * 
 * In addition, the Operator module supports combining existing gates to form
 * new gates. This includes operations such as Operator composition, tensor
 * products of Operators, and producing controlled gates.
 * 
 * Author: Barak Nehoran
 * Advisor: Iasonas Petras
 */

#include "operator.h"
#include "state.h"
#include "vector.h"
#include "register.h"
#include <stdlib.h>
#include <assert.h>
#include <complex.h>
#include <time.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

/* An Operators is represented by a pointer to an OperatorStruct,
   which stores one of 
   (a) a (pointer to a) one-to-one function mapping basis states to 
      other basis states.
   (b) a one-to-many function mapping basis states to sets of other 
      basis states.
   (c) a 2^k-by-2^k matrix representing the Operator's effect on k 
      of the n qubits in a state.
   as well as arrays of positive integers representing the qubits 
   acting as the controls and targets of the gate (whenever relevant). 
   An OperatorStruct may also store extra data when relevant to its 
   operation. */
struct OperatorStruct {
   char* name;
   enum {
      CNOT, CPHASE, SWAP, PAULI_X, PAULI_Y, PAULI_Z, HADAMARD,
      PHASE_S, PHASE_T, ROT,
      MULT_ADD, MULT_SUB,
      COMPOSITE, CONTROLLED,
      OTHER
   } type;
   int n;
   // arrays specifying the controls and target bits.
   // All int arrays must be termintated by a -1.
   int* controls; // 1-triggered controls
   int* controls_0; // 0-triggered controls. May be null if none.
   int* targets; 
   struct Pair (*func) (struct Pair, void*);
   struct Pair* (*func2) (struct Pair, void*);
   double complex** matrix;
   // Additional data relevant to the operation of some Operators
   void* extra;
   void (*free_extra) (void*); // frees the memory pointed to by extra
};

/* a string representation of the Operator */
char* Operator_toString (Operator op) {
   // The string representation of the list of operators
   return op->name;
   // TODO: go through linked list of ops
   // TODO: make a defensive copy of op->name so that cannot be changed by client
   // n = 100; //Max name length
   // char* s[n];
   // snprintf(s, n, "%s(", op->name);
   // for (int* p = op->controls; p != NULL && *p != -1; p++) {
   //    snprintf(s, n, "%d ",*(p));
   // }
   // for (int* p = op->controls_0; p != NULL && *p != -1; p++) {
   //    snprintf(s, n, "~%d ",*(p));
   // }
   // snprintf(s, n, "->");
   // for (int* p = op->targets; p != NULL && *p != -1; p++) {
   //    snprintf(s, n, " %d",*(p));
   // }
   // printf(")\n");
}

/*
 * Standard Gates / Constructors
 */

/* Returns a controlled not (CNOT) Operator with multiple controls and targets 
   on n qubits that controls from each of the qubits in controls 
   and flips each of the qubits in targets.
   Both controls and targets must be arrays terminated by a -1. */
Operator Operator_cnot (int n, int* controls, int* targets) {
   struct Pair cnot_helper (struct Pair p, void* extra) {
      Operator op = (Operator) extra;
      bool trigger = true;
      int* cur;
      for (cur = op->controls; *(cur) != -1; cur++) {
         assert(*(cur) >= 0 && *(cur) < op->n);
         if (!(p.index & 1L << *(cur))) {
            trigger = false;
            break;
         }
      }
      if (!trigger)
         return p;
      for (cur = op->targets; *(cur) != -1; cur++) {
         assert(*(cur) >= 0 && *(cur) < op->n);
         p.index = p.index ^ 1L << *(cur); //bitwise xor
      }
      return p;
   }
   Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   if (op == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   op->name = "CNot";
   op->type = CNOT;
   op->n = n;
   // defensive a defensive copy of controls
   int num_contr;
   for (num_contr = 0; controls[num_contr] != -1; num_contr++);
   int* controls_cpy = (int*)malloc((num_contr+1) * sizeof(int));
   for (int i = 0; i < num_contr; i++) {
      controls_cpy[i] = controls[i];
   }
   controls_cpy[num_contr] = -1;
   op->controls = controls_cpy;
   op->controls_0 = NULL;
   // defensive a defensive copy of targets
   int num_targ;
   for (num_targ = 0; targets[num_targ] != -1; num_targ++);
   int* targets_cpy = (int*)malloc((num_targ+1) * sizeof(int));
   for (int i = 0; i < num_targ; i++) {
      targets_cpy[i] = targets[i];
   }
   targets_cpy[num_targ] = -1;
   op->targets = targets_cpy;
   op->func = &cnot_helper;
   op->func2 = NULL;
   op->matrix = NULL;
   op->extra = NULL;
   op->free_extra = NULL;
   return op;
}


/* Returns a controlled not (CNOT) Operator with multiple controls and targets 
   on n qubits that flips each bit specified in targets if 
   (a) every bit specified in controls_1 is a 1 and 
   (b) every bit specidied in controls_0 is a 0.
   All three arrays must be terminated by a -1. */
Operator Operator_cnot_0 (int n, int* controls_1, int* controls_0, 
      int* targets) {
   struct Pair cnot_0_helper (struct Pair p, void* extra) {
      Operator op = (Operator) extra;
      bool trigger = true;
      int* cur;
      for (cur = op->controls; *(cur) != -1; cur++) {
         assert(*(cur) >= 0 && *(cur) < op->n);
         if (!(p.index & 1L << *(cur))) {
            trigger = false;
            break;
         }
      }
      for (cur = op->controls_0; *(cur) != -1; cur++) {
         assert(*(cur) >= 0 && *(cur) < op->n);
         if (p.index & 1L << *(cur)) {
            trigger = false;
            break;
         }
      }
      if (!trigger)
         return p;
      for (cur = op->targets; *(cur) != -1; cur++) {
         assert(*(cur) >= 0 && *(cur) < op->n);
         p.index = p.index ^ 1L << *(cur); //bitwise xor
      }
      return p;
   }
   Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   if (op == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   op->name = "CNot";
   op->type = CNOT;
   op->n = n;
   // defensive a defensive copy of controls
   int num_contr_1;
   for (num_contr_1 = 0; controls_1[num_contr_1] != -1; num_contr_1++);
   int* controls_1_cpy = (int*)malloc((num_contr_1+1) * sizeof(int));
   for (int i = 0; i < num_contr_1; i++) {
      controls_1_cpy[i] = controls_1[i];
   }
   controls_1_cpy[num_contr_1] = -1;
   op->controls = controls_1_cpy;
   // defensive a defensive copy of controls
   int num_contr_0;
   for (num_contr_0 = 0; controls_0[num_contr_0] != -1; num_contr_0++);
   int* controls_0_cpy = (int*)malloc((num_contr_0+1) * sizeof(int));
   for (int i = 0; i < num_contr_0; i++) {
      controls_0_cpy[i] = controls_0[i];
   }
   controls_0_cpy[num_contr_0] = -1;
   op->controls_0 = controls_0_cpy;
   // defensive a defensive copy of targets
   int num_targ;
   for (num_targ = 0; targets[num_targ] != -1; num_targ++);
   int* targets_cpy = (int*)malloc((num_targ+1) * sizeof(int));
   for (int i = 0; i < num_targ; i++) {
      targets_cpy[i] = targets[i];
   }
   targets_cpy[num_targ] = -1;
   op->targets = targets_cpy;
   op->func = &cnot_0_helper;
   op->func2 = NULL;
   op->matrix = NULL;
   op->extra = NULL;
   op->free_extra = NULL;
   return op;
}


/* Returns a controlled phase Operator on n qubits
   that controls from each of the qubits in controls
   (negates the amplitude whenever all controls are 1) */
Operator Operator_cphase (int n, int* controls) {
   struct Pair cphase_helper (struct Pair p, void* extra) {
      Operator op = (Operator) extra;
      bool trigger = true;
      int* cur;
      for (cur = op->controls; *(cur) != -1; cur++) {
         assert(*(cur) >= 0 && *(cur) < op->n);
         if (!(p.index & 1L << *(cur))) {
            trigger = false;
            break;
         }
      }
      if (trigger) {
         p.val = -1 * p.val;
      }
      return p;
   }
   Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   if (op == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   op->name = "CPhase";
   op->type = CPHASE;
   op->n = n;
   // defensive a defensive copy of controls
   int num_contr;
   for (num_contr = 0; controls[num_contr] != -1; num_contr++);
   int* controls_cpy = (int*)malloc((num_contr+1) * sizeof(int));
   for (int i = 0; i < num_contr; i++) {
      controls_cpy[i] = controls[i];
   }
   controls_cpy[num_contr] = -1;
   op->controls = controls_cpy;
   op->controls_0 = NULL;
   op->targets = NULL;
   op->func = &cphase_helper;
   op->func2 = NULL;
   op->matrix = NULL;
   op->extra = NULL;
   op->free_extra = NULL;
   return op;
}

/* Returns the n-qubit Operator which swaps qubits j and k */
Operator Operator_swap (int n, int j, int k) {
   struct Pair swap_helper (struct Pair p, void* extra) {
      Operator op = (Operator) extra;
      assert(op->targets[0] >= 0 && op->targets[0] < op->n);
      assert(op->targets[1] >= 0 && op->targets[1] < op->n);
      if (!(p.index & (1L << op->targets[0])) // if the two bits are different
            != !(p.index & (1L << op->targets[1]))) { // then flip both
         p.index = p.index ^ (1L << op->targets[0]) ^ (1L << op->targets[1]);
      }
      return p;
   }
   Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   if (op == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   op->name = "Swap";
   op->type = SWAP;
   op->n = n;
   op->controls = NULL;
   op->controls_0 = NULL;
   int* targets = (int*)malloc(3*sizeof(int));
   targets[0] = j;
   targets[1] = k;
   targets[2] = -1;
   op->targets = targets;
   op->func = &swap_helper;
   op->func2 = NULL;
   op->matrix = NULL;
   op->extra = NULL;
   op->free_extra = NULL;
   return op;
}


/* the X, Y, and Z Pauli spin Operators on qubit k */
Operator Operator_pauli_X (int n, int k) {
   struct Pair pauli_X_helper (struct Pair p, void* extra) {
      Operator op = (Operator) extra;
      // int* cur; // use to allow flipping multiple bits
      // for (cur = op->targets; *(cur) != -1; cur++) {
      //    assert(*(cur) >= 0 && *(cur) < op->n);
      //    p.index = p.index ^ 1L << *(cur); //bitwise xor
      // };
      assert(*(op->targets) >= 0 && *(op->targets) < op->n);
      p.index = p.index ^ 1L << *(op->targets); //bitwise xor
      return p;
   }
   Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   if (op == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   op->name = "PauliX";
   op->type = PAULI_X;
   op->n = n;
   op->controls = NULL;
   op->controls_0 = NULL;
   int* targets = (int*)malloc(2*sizeof(int));
   targets[0] = k;
   targets[1] = -1;
   op->targets = targets;
   op->func = &pauli_X_helper;
   op->func2 = NULL;
   op->matrix = NULL;
   op->extra = NULL;
   op->free_extra = NULL;
   return op;
}
Operator Operator_pauli_Y (int n, int k) {
   struct Pair pauli_Y_helper (struct Pair p, void* extra) {
      Operator op = (Operator) extra;
      assert(*(op->targets) >= 0 && *(op->targets) < op->n);
      if (p.index & (1L << *(op->targets))) {
         p.val = -1 * p.val;
      }
      p.val = I * p.val;
      p.index = p.index ^ 1L << *(op->targets); //bitwise xor
      return p;
   }
   Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   if (op == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   op->name = "PauliY";
   op->type = PAULI_Y;
   op->n = n;
   op->controls = NULL;
   op->controls_0 = NULL;
   int* targets = (int*)malloc(2*sizeof(int));
   targets[0] = k;
   targets[1] = -1;
   op->targets = targets;
   op->func = &pauli_Y_helper;
   op->func2 = NULL;
   op->matrix = NULL;
   op->extra = NULL;
   op->free_extra = NULL;
   return op;
}
Operator Operator_pauli_Z (int n, int k) {
   struct Pair pauli_Z_helper (struct Pair p, void* extra) {
      Operator op = (Operator) extra;
      assert(*(op->targets) >= 0 && *(op->targets) < op->n);
      if (p.index & (1L << *(op->targets))) {
         p.val = -1 * p.val;
      }
      return p;
   }
   Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   if (op == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   op->name = "PauliZ";
   op->type = PAULI_Z;
   op->n = n;
   op->controls = NULL;
   op->controls_0 = NULL;
   int* targets = (int*)malloc(2*sizeof(int));
   targets[0] = k;
   targets[1] = -1;
   op->targets = targets;
   op->func = &pauli_Z_helper;
   op->func2 = NULL;
   op->matrix = NULL;
   op->extra = NULL;
   op->free_extra = NULL;
   return op;
}

/* the single-qubit hadamard Operator on qubit k */
Operator Operator_hadamard (int n, int k) {
   struct Pair* hadamard_helper (struct Pair p, void* extra) {
      Operator op = (Operator) extra;
      assert(*(op->targets) >= 0 && *(op->targets) < op->n);
      static struct Pair arr[3];
      arr[0].index = p.index;
      arr[1].index = p.index ^ 1L << *(op->targets); //bitwise xor
      if (p.index & (1L << *(op->targets))) { // if the bit is a 1
         arr[0].val = -1 * (arr[1].val = p.val / sqrt(2.0)); // state: |->
      }
      else { // the bit is a 0
         arr[0].val = arr[1].val = p.val / sqrt(2.0); // state: |+>
      }
      arr[2].index = -1;
      arr[2].val = 0.0;
      return arr;
   }
   Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   if (op == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   op->name = "Hadamard";
   op->type = HADAMARD;
   op->n = n;
   op->controls = NULL;
   op->controls_0 = NULL;
   int* targets = (int*)malloc(2*sizeof(int));
   targets[0] = k;
   targets[1] = -1;
   op->targets = targets;
   op->func = NULL;
   op->func2 = &hadamard_helper;
   op->matrix = NULL;
   op->extra = NULL;
   op->free_extra = NULL;
   return op;
}

/* The pi/4 phase gate (phase_S^2 = pauli_Z) on qubit k */
Operator Operator_phase_S (int n, int k) {
   struct Pair phase_S_helper (struct Pair p, void* extra) {
      Operator op = (Operator) extra;
      assert(*(op->targets) >= 0 && *(op->targets) < op->n);
      if (p.index & (1L << *(op->targets))) {
         p.val = I * p.val;
      }
      return p;
   }
   Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   if (op == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   op->name = "PhaseS";
   op->type = PHASE_S;
   op->n = n;
   op->controls = NULL;
   op->controls_0 = NULL;
   int* targets = (int*)malloc(2*sizeof(int));
   targets[0] = k;
   targets[1] = -1;
   op->targets = targets;
   op->func = &phase_S_helper;
   op->func2 = NULL;
   op->matrix = NULL;
   op->extra = NULL;
   op->free_extra = NULL;
   return op;
}

/* The pi/8 phase gate (phase_T^2 = phase_S) on qubit k */
Operator Operator_phase_T (int n, int k) {
   struct Pair phase_T_helper (struct Pair p, void* extra) {
      Operator op = (Operator) extra;
      assert(*(op->targets) >= 0 && *(op->targets) < op->n);
      if (p.index & (1L << *(op->targets))) {
         p.val = (1 + I) * p.val / sqrt(2.0);
      }
      return p;
   }
   Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   if (op == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   op->name = "PhaseT";
   op->type = PHASE_T;
   op->n = n;
   op->controls = NULL;
   op->controls_0 = NULL;
   int* targets = (int*)malloc(2*sizeof(int));
   targets[0] = k;
   targets[1] = -1;
   op->targets = targets;
   op->func = &phase_T_helper;
   op->func2 = NULL;
   op->matrix = NULL;
   op->extra = NULL;
   op->free_extra = NULL;
   return op;
}

/* An arbitrary rotation on the spin of qubit k
   Rotates the spin around the axis (ax,ay,az) by
   amount angle in radians */
Operator Operator_rot (int n, int k, double ax, double ay, double az, 
      double angle) {
   // TODO
   assert(false);
   return NULL;
}

/* Returns an operator that performs the addition and multiplication
   of Registers of qubits. 
   Specificically, the operator takes an n-qubit state with three Registers: 
      |x>, |y>, and |z>
   where |x> has xn := (x->high - x->low) qubits of which 
   xm := (x->high - x->zero) represent the integer part, leaving 
   (x->zero - z->low) to represent the fractional part,
   and where the qubit representing bit 2^0 of x is qubit number x->zero. 
   The |y> and |z> registers are represented likewise.
   The result is the product of the numbers represented by |x> and |y> 
   plus the number represented by |z>, and is stored in the |z> register.
   That is, the calculation performed is 
      z = x*y + z
   In order to allow enough room to store the result, 
   zm must be at least xm + ym + 1, and zn must be at least xn + yn + 1,
   with an extra (most significant) qubit to store the carry bit 
   (otherwise overflow can occur). */
Operator Operator_multiply_add(int n, Register x, Register y, Register z) {
   struct xyz_Registers {
      int x_h, x_0, x_l, y_h, y_0, y_l, z_h, z_0, z_l;
   };
   struct Pair multiply_add_helper (struct Pair p, void* extra) {
      Operator op = (Operator) extra;
      struct xyz_Registers* op_data = (struct xyz_Registers*) op->extra;
      int x_h = op_data->x_h;
      int x_0 = op_data->x_0;
      int x_l = op_data->x_l;
      int y_h = op_data->y_h;
      int y_0 = op_data->y_0;
      int y_l = op_data->y_l;
      int z_h = op_data->z_h;
      int z_0 = op_data->z_0;
      int z_l = op_data->z_l;
      // get the numbers stored in each register
      long x_reg = (p.index % (1L << x_h)) >> x_l;
      long y_reg = (p.index % (1L << y_h)) >> y_l;
      long z_reg = (p.index % (1L << z_h)) >> z_l;
      long prod = x_reg * y_reg;
      int prod_num_frac_bits = (x_0 - x_l) + (y_0 - y_l);
      int z_num_frac_bits = (z_0 - z_l); // == zn - zm
      long res_reg;
      if (z_num_frac_bits > prod_num_frac_bits) // shift left to fit z register
         res_reg = z_reg + (prod<<(z_num_frac_bits - prod_num_frac_bits));
      else // shift right to fit z register
         res_reg = z_reg + (prod>>(prod_num_frac_bits - z_num_frac_bits));
      res_reg = res_reg % (1L << (z_h - z_l)); // remove overflow bits
      p.index = p.index + ((res_reg - z_reg) << z_l); // z_reg := res_reg
      return p;
   }
   int xn = x->high - x->low;
   int xm = x->high - x->zero;
   int yn = y->high - y->low;
   int ym = y->high - y->zero;
   int zn = z->high - z->low;
   int zm = z->high - z->zero;
   // assert(zn >= yn + xn);
   // assert(zm >= ym + xm);
   assert(Register_isValid(x) && Register_isValid(y) && Register_isValid(z));
   // the registers cannot be overlapping or include qubits beyond the state
   assert(Register_have_no_overlap(x,y));
   assert(Register_have_no_overlap(y,z));
   assert(Register_have_no_overlap(z,x));
   // assert(x_l >= 0 && y_l >= 0 && z_l >= 0); // must be if registers valid
   assert(x->high <= n && y->high <= n && z->high <= n);
   
   Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   if (op == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   op->name = "Mult-Add";
   op->type = MULT_ADD;
   op->n = n;
   int* controls = (int*)malloc(4*sizeof(int));
   controls[0] = x->low;
   controls[1] = x->zero;
   controls[2] = x->high;
   controls[3] = -1;
   op->controls = controls;
   int* controls_0 = (int*)malloc(4*sizeof(int));
   controls_0[0] = y->low;
   controls_0[1] = y->zero;
   controls_0[2] = y->high;
   controls_0[3] = -1;
   op->controls_0 = controls_0;
   int* targets = (int*)malloc(4*sizeof(int));
   targets[0] = z->low;
   targets[1] = z->zero;
   targets[2] = z->high;
   targets[3] = -1;
   op->targets = targets;
   op->func = &multiply_add_helper;
   op->func2 = NULL;
   op->matrix = NULL;
   struct xyz_Registers* op_data = (struct xyz_Registers*)malloc(
         sizeof(struct xyz_Registers));
   op_data->x_h = x->high;
   op_data->x_0 = x->zero;
   op_data->x_l = x->low;
   op_data->y_h = y->high;
   op_data->y_0 = y->zero;
   op_data->y_l = y->low; 
   op_data->z_h = z->high;
   op_data->z_0 = z->zero;
   op_data->z_l = z->low; 
   op->extra = (void*) op_data;
   void free_extra(void* extra) {
      struct xyz_Registers* op_data = (struct xyz_Registers*) extra;
      free(op_data);
   }
   op->free_extra = &free_extra;
   return op;
}

/* Returns an operator that performs the subtraction and multiplication
   of Registers of qubits. 
   Specificically, the operator takes an n-qubit state with three Registers: 
      |x>, |y>, and |z>
   where |x> has xn := (x->high - x->low) qubits of which 
   xm := (x->high - x->zero) represent the integer part, leaving 
   (x->zero - z->low) to represent the fractional part,
   and where the qubit representing bit 2^0 of x is qubit number x->zero. 
   The |y> and |z> registers are represented likewise.
   The result is the product of the numbers represented by |x> and |y> 
   subtracted from the number represented by |z>, and is stored in the |z> 
   register. That is, the calculation performed is 
      z = z - x*y
   In order to allow enough room to store the result, 
   zm must be at least xm + ym + 1, and zn must be at least xn + yn + 1,
   with an extra (most significant) qubit to store the carry bit 
   (otherwise overflow can occur). */
Operator Operator_multiply_subtract_from(int n, 
      Register x, Register y, Register z) {
   struct xyz_Registers {
      int x_h, x_0, x_l, y_h, y_0, y_l, z_h, z_0, z_l;
   };
   struct Pair multiply_sub_helper (struct Pair p, void* extra) {
      Operator op = (Operator) extra;
      struct xyz_Registers* op_data = (struct xyz_Registers*) op->extra;
      int x_h = op_data->x_h;
      int x_0 = op_data->x_0;
      int x_l = op_data->x_l;
      int y_h = op_data->y_h;
      int y_0 = op_data->y_0;
      int y_l = op_data->y_l;
      int z_h = op_data->z_h;
      int z_0 = op_data->z_0;
      int z_l = op_data->z_l;
      // get the numbers stored in each register
      long x_reg = (p.index % (1L << x_h)) >> x_l;
      long y_reg = (p.index % (1L << y_h)) >> y_l;
      long z_reg = (p.index % (1L << z_h)) >> z_l;
      long prod = x_reg * y_reg;
      int prod_num_frac_bits = (x_0 - x_l) + (y_0 - y_l);
      int z_num_frac_bits = (z_0 - z_l); // == zn - zm
      long res_reg;
      if (z_num_frac_bits > prod_num_frac_bits) // shift left to fit z register
         res_reg = z_reg - (prod<<(z_num_frac_bits - prod_num_frac_bits));
      else // shift right to fit z register
         res_reg = z_reg - (prod>>(prod_num_frac_bits - z_num_frac_bits));
      assert(res_reg <= z_reg); // check for oveflow TODO:remove after testing
      res_reg = res_reg % (1L << (z_h - z_l)); // remove overflow bits
      p.index = p.index + ((res_reg - z_reg) << z_l); // z_reg := res_reg
      return p;
   }
   int xn = x->high - x->low;
   int xm = x->high - x->zero;
   int yn = y->high - y->low;
   int ym = y->high - y->zero;
   int zn = z->high - z->low;
   int zm = z->high - z->zero;
   // assert(zn >= yn + xn);
   // assert(zm >= ym + xm);
   assert(Register_isValid(x) && Register_isValid(y) && Register_isValid(z));
   // the registers cannot be overlapping or include qubits beyond the state
   assert(Register_have_no_overlap(x,y));
   assert(Register_have_no_overlap(y,z));
   assert(Register_have_no_overlap(z,x));
   // assert(x_l >= 0 && y_l >= 0 && z_l >= 0); // must be if registers valid
   assert(x->high <= n && y->high <= n && z->high <= n);
   
   Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   if (op == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   op->name = "Mult-SUB";
   op->type = MULT_SUB;
   op->n = n;
   int* controls = (int*)malloc(4*sizeof(int));
   controls[0] = x->low;
   controls[1] = x->zero;
   controls[2] = x->high;
   controls[3] = -1;
   op->controls = controls;
   int* controls_0 = (int*)malloc(4*sizeof(int));
   controls_0[0] = y->low;
   controls_0[1] = y->zero;
   controls_0[2] = y->high;
   controls_0[3] = -1;
   op->controls_0 = controls_0;
   int* targets = (int*)malloc(4*sizeof(int));
   targets[0] = z->low;
   targets[1] = z->zero;
   targets[2] = z->high;
   targets[3] = -1;
   op->targets = targets;
   op->func = &multiply_sub_helper;
   op->func2 = NULL;
   op->matrix = NULL;
   struct xyz_Registers* op_data = (struct xyz_Registers*)malloc(
         sizeof(struct xyz_Registers));
   op_data->x_h = x->high;
   op_data->x_0 = x->zero;
   op_data->x_l = x->low;
   op_data->y_h = y->high;
   op_data->y_0 = y->zero;
   op_data->y_l = y->low; 
   op_data->z_h = z->high;
   op_data->z_0 = z->zero;
   op_data->z_l = z->low; 
   op->extra = (void*) op_data;
   void free_extra(void* extra) {
      struct xyz_Registers* op_data = (struct xyz_Registers*) extra;
      free(op_data);
   }
   op->free_extra = &free_extra;
   return op;
}


/* Frees the operator op. */
void Operator_free(Operator op) {
   assert(op); // should remove? should op == NULL represent identity??
   if (op->controls)
      free(op->controls);
   if (op->controls_0)
      free(op->controls_0);
   if (op->targets)
      free(op->targets);
   if (op->extra) {
      assert(op->free_extra);
      void (*free_extra) (void*) = op->free_extra;
      void* extra = op->extra;
      free_extra(extra);
   }
   free(op);
}


/* Returns whether the given Operator is unitary */
bool Operator_is_unitary (Operator op) {
   switch(op->type) {
      case CNOT: case CPHASE: case SWAP: 
      case PAULI_X: case PAULI_Y: case PAULI_Z: case HADAMARD:
      case PHASE_S: case PHASE_T: case ROT:
      case COMPOSITE: case CONTROLLED:
      case MULT_ADD: case MULT_SUB:
         return true;
      case OTHER: default:
         return false;
   }
}

/* Returns whether the given Operator is hermitian */
bool Operator_is_hermitian (Operator op) {
   switch(op->type) {
      case CNOT: case CPHASE: case SWAP: 
      case PAULI_X: case PAULI_Y: case PAULI_Z: case HADAMARD:
      case PHASE_S: case PHASE_T: case ROT:
         return true;
      case COMPOSITE: case CONTROLLED:
      case MULT_ADD: case MULT_SUB:
         return false;
      case OTHER: default:
         return false;
   }
}

/* Returns the hermitian conjugate of the Operator op */
Operator Operator_dagger (Operator op) {
   if (Operator_is_hermitian(op)) {
      return op;
   }
   else {
      return NULL;
   }
}

/* Takes an n-qubit state |s> and returns the n-qubit state
   that is the result of applying the Operator to |s> */
State Operator_apply (Operator op, State s) {
   if (op->func != NULL) { // op is defined as a one-to-one function
      State s_new = State_map(s, op->func,op);
      State_free(s);
      s = s_new;
   }
   else if (op->func2 != NULL) { // op is defined as a one-to-many function
      State s_new = State_map_mult(s, op->func2,op);
      State_free(s);
      s = s_new;
   }
   else if (op->matrix != NULL) { // op is defined as a small matrix
      fprintf(stderr, "Matrix application unimplemented! Aborting...\n");
      assert(false);
   }
   else if (op->type == COMPOSITE) {
      Operator* arr = (Operator*) op->extra;
      for (Operator* cur = arr; *(cur) != NULL; cur++) {
         s = Operator_apply (*(cur), s);
      }
      return s;
   }
   return s;
}

/* Returns an Operator that is the result of taking the
   tensor product of all the Operators in op */
Operator Operator_tensor (Operator* ops) {
   fprintf(stderr, "Unimplemented\n");
   assert(false);
}

/* Returns the Operator that is the same as applying each
   of the Operators in ops in sequence.
   The argument ops must be a null-terminated array of Operators.
   Destroys each of the argument operators. */
Operator Operator_compose (Operator* ops) {
   assert(ops);
   void free_extra (void* arg) {
      Operator* ops = (Operator*) arg;
      for (Operator* cur = ops; *cur != NULL; cur++) {
         Operator_free(*cur);
      }
      free(ops);
   }
   Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   if (op == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   op->name = "Composite";
   op->type = COMPOSITE;
   int counter;
   op->n = 0;
   for (counter = 0; ops[counter] != NULL; counter++) {
      if (ops[counter]->n > op->n) {
         op->n = ops[counter]->n;
      }
   }
   Operator* ops_cpy = (Operator*)malloc((counter+1) * sizeof(Operator*));
   for (int i = 0; i < counter; i++) {
      ops_cpy[i] = ops[i];
   }
   ops_cpy[counter] = NULL;
   op->extra = (void*) ops_cpy;
   op->controls = NULL;
   op->controls_0 = NULL;
   op->targets = NULL;
   // op->func = &compose_helper;
   op->func = NULL;
   op->func2 = NULL;
   op->matrix = NULL;
   op->free_extra = &free_extra;
   return op;
}

/* Returns the Operator that is the same as applying each
   of the two Operators.
   Destroys the two argument operators. */
Operator Operator_compose2 (Operator op1, Operator op2) {
   Operator ops[3] = {op1, op2, NULL};
   Operator op = Operator_compose(ops);
   return op;
}

/* Takes a single-qubit (2 by 2) Operator op and converts it to
   a controlled Operator on n qubits with the given control
   and target qubits */
Operator Operator_controlled (Operator op, int n, int control, int target) {
   // TODO
   assert(false);
   return NULL;
}

/* Takes an Operator op and converts it to
   a controlled Operator on n qubits with the given control qubits */
// TODO: in progress. Does not yet work.
Operator Operator_controlled2 (Operator op, int n, int* controls) {
   // void free_extra (void* arg) {
   //    Operator* ops = (Operator*) arg;
   //    free(ops);
   // }
   // Operator op = (Operator)malloc(sizeof(struct OperatorStruct));
   // if (op == NULL) { // insufficient memory
   //    return NULL;
   // }
   // memset(op, 0x0, sizeof(struct OperatorStruct));
   // op->name = "Controlled";
   // op->type = CONTROLLED;
   // int counter;
   // op->n = 0;
   // for (counter = 0; ops[counter] != NULL; counter++) {
   //    if (ops[counter]->n > op->n) {
   //       op->n = ops[counter]->n;
   //    }
   // }
   // Operator* ops_cpy = (Operator*)malloc((counter+1) * sizeof(Operator*));
   // for (int i = 0; i < counter; i++) {
   //    ops_cpy[i] = ops[i];
   // }
   // ops_cpy[counter] = NULL;
   // op->extra = (void*) ops_cpy;
   // op->controls = NULL;
   // op->controls_0 = NULL;
   // op->targets = NULL;
   // // op->func = &compose_helper;
   // op->func = NULL;
   // op->func2 = NULL;
   // op->matrix = NULL;
   // op->free_extra = &free_extra;
   // op->next = NULL;
   // return op;
   
   //Buggy: TODO test
   static struct Pair arr[2];
   struct Pair* controlled_helper (struct Pair p, void* extra) {
      Operator opc = (Operator) extra;
      Operator opt = (Operator) opc->extra;
      bool trigger = true;
      int* cur;
      fprintf(stderr, "%d\n", 1);
      for (cur = opc->controls; *(cur) != -1; cur++) {
         assert(*(cur) >= 0 && *(cur) < opc->n);
         if (!(p.index & 1L << *(cur))) {
            trigger = false;
            break;
         }
      }
      arr[0] = p;
      arr[1].index = -1;
      arr[1].val = 0.0;
      fprintf(stderr, "%d\n", 2);
      if (trigger) {
         if (opt->func != NULL) { // op is defined as a one-to-one function
            fprintf(stderr, "%d\n", 3);
            p = opt->func(p,opt);
            fprintf(stderr, "%d\n", 4);
         }
         else if (opt->func2 != NULL) { // op defined as a one-to-many function
            return opt->func2(p,opt);
         }
         else if (opt->matrix != NULL) { // op is defined as a small matrix
            fprintf(stderr, "Matrix application unimplemented! Aborting...\n");
            assert(false);
         }
      }
      fprintf(stderr, "%d\n", 10);
      return NULL;
   }
   Operator opc = (Operator)malloc(sizeof(struct OperatorStruct));
   if (opc == NULL) { // insufficient memory
      return NULL;
   }
   memset(op, 0x0, sizeof(struct OperatorStruct));
   opc->name = "ControlledGate";
   opc->n = n;
   // defensive a defensive copy of controls
   int num_contr;
   for (num_contr = 0; controls[num_contr] != -1; num_contr++);
   int* controls_cpy = (int*)malloc((num_contr+1) * sizeof(int));
   for (int i = 0; i < num_contr; i++) {
      controls_cpy[i] = controls[i];
   }
   controls_cpy[num_contr] = -1;
   opc->controls = controls_cpy;
   int* targets = (int*)malloc(1*sizeof(int));
   targets[0] = -1;
   opc->targets = targets;
   opc->func = NULL;
   opc->func2 = &controlled_helper;
   opc->matrix = NULL;
   opc->extra = op;
   fprintf(stderr, "%d\n", 144);
   return opc;
}


/*--------------------------------------------------------------------*/
/* Unit testing for operator.c                                          */
/*--------------------------------------------------------------------*/

bool Operator_isValid(Operator op) {
   // TODO: implement
   return false;
}

//TODO: write tests
void test_cnot (int n) {}
void test_cphase (int n) {}
void test_swap (int n) {}
void test_pauli_X (int n) {}
void test_pauli_Y (int n) {}
void test_pauli_Z (int n) {}
void test_hadamard (int n) {}
void test_phase_S (int n) {}
void test_phase_T (int n) {}
void test_rot (int n) {}
void test_multiply_add (int n) {}
void test_is_unitary (int n) {}
void test_is_hermitian (int n) {}
void test_dagger (int n) {}
void test_apply (int n) {}
void test_tensor (int n) {}
void test_compose (int n) {}
void test_controlled (int n) {}

/* Same as apply but prints out verbose results. 
   Useful for testing and debugging. */
State Operator_print_apply(Operator op, State s) {
   printf("Applying %s(", Operator_toString(op));
   for (int* p = op->controls; p != NULL && *p != -1; p++) {
      printf("%d ",*(p));
   }
   for (int* p = op->controls_0; p != NULL && *p != -1; p++) {
      printf("~%d ",*(p));
   }
   printf("->");
   for (int* p = op->targets; p != NULL && *p != -1; p++) {
      printf(" %d",*(p));
   }
   printf(")\n");
   fflush(stdout);
   if (op->type == COMPOSITE) {
      Operator* arr = (Operator*) op->extra;
      for (int i = 0; arr[i] != NULL; i++) {
         printf("---> composite[%d]: ",i); fflush(stdout);
         s = Operator_print_apply (arr[i], s);
      }
      return s;
   }
   s = Operator_apply(op,s);
   State_print(s); fflush(stdout);
   return s;
}

void Operator_print_tests(void) {
   printf("\nPrinting Tests:\n---------------\n");
   
   int controls[10] = { 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
   int targets[10] = { 2, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
   Operator op;
   State s = State_new_integer(2,2);
   s = State_add_qubit_as(s,1,1,0); // create the state |10+>
   State_print(s); fflush(stdout);
   
   op = Operator_cnot(3,controls, targets);
   s = Operator_print_apply(op,s);
   Operator_free(op);
   
   op = Operator_pauli_X(3,1);
   s = Operator_print_apply(op,s);
   Operator_free(op);
   
   op = Operator_pauli_Z(3,2);
   s = Operator_print_apply(op,s);
   Operator_free(op);
   
   op = Operator_pauli_Y(3,0);
   s = Operator_print_apply(op,s);
   Operator_free(op);
   
   op = Operator_hadamard(3,2);
   s = Operator_print_apply(op,s);
   Operator_free(op);
   
   op = Operator_swap(3,0,1);
   s = Operator_print_apply(op,s);
   Operator_free(op);
   
   State_free(s);
   
   s = State_new_integer(4,6);
   printf("\nNew state\n----------\n");
   State_print(s); fflush(stdout);
   
   op = Operator_hadamard(4,3);
   s = Operator_print_apply(op,s);
   Operator_free(op);
   
   op = Operator_hadamard(4,2);
   s = Operator_print_apply(op,s);
   Operator_free(op);
   
   // op = Operator_hadamard(4,3);
   // printf("Applying %s(_->%d)\n", op->name, op->targets[0]);
   // s = Operator_apply(op,s);
   // State_print(s); fflush(stdout);
   // Operator_free(op);
   
   controls[0] = 3;
   controls[1] = 2;
   controls[2] = -1;
   targets[0] = 0;
   targets[2] = -1;
   op = Operator_cnot(4,controls, targets);
   s = Operator_print_apply(op,s);
   Operator_free(op);
   
   controls[0] = 2;
   controls[1] = -1;
   int controls_0[2] = {3,-1};
   targets[0] = 0;
   targets[2] = -1;
   op = Operator_cnot_0(4,controls, controls_0, targets);
   s = Operator_print_apply(op,s); fflush(stdout);
   Operator_free(op);
   
   // controls[0] = 2;
   // controls[1] = -1;
   // op = Operator_swap(4,0,1);
   // op = Operator_controlled2(op,4,controls);
   // s = Operator_print_apply(op,s);
   // Operator_free(op);
   
   State_free(s);
   
   printf("\nTesting Mult-Add:\n---------------\n");
   void mult_add(long x, int xn, int xm, long y, int yn, 
      int ym, long z, int zn, int zm) {
      assert(xn >= xm);
      assert(yn >= ym);
      assert(zn >= zm);
      printf("x = %f\n",x / pow(2.0,xn-xm));
      printf("y = %f\n",y / pow(2.0,yn-ym));
      printf("z = %f\n",z / pow(2.0,zn-zm));
      int n = xn + yn + zn;
      int x_0 = xn - xm + yn + zn;
      int y_0 = yn - ym + zn;
      int z_0 = zn - zm;
      Register xr = Register_new(x_0 - (xn - xm), x_0, x_0 + xm);
      Register yr = Register_new(y_0 - (yn - ym), y_0, y_0 + ym);
      Register zr = Register_new(z_0 - (zn - zm), z_0, z_0 + zm);
      long input = (x << (yn + zn)) + (y << zn) + z;
      State s = State_new_integer(n, input);
      State_print(s); fflush(stdout);
      
      Operator op = Operator_multiply_add(n,xr,yr,zr);
      s = Operator_print_apply(op,s);
      Operator_free(op);
      
      long output = State_measure_all(s);
      long result = output % (1L << zn);
      printf("result = x*y + z = %f\n", result/pow(2.0,zn-zm)); fflush(stdout);
      
      Register_free(xr);
      Register_free(yr);
      Register_free(zr);
      State_free(s);
   }
   mult_add(0x72,8,7,0x91,8,7,0x3253,16,14);
}

void Operator_algorithm_tests(void) {
   printf("\nAlgorithm Tests:\n----------------\n");
   int controls[10] = { 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
   int targets[10] = { 2, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
   Operator op;
   State s = State_new_integer(2,2);
   s = State_add_qubit_as(s,1,-1,0); // create the state |10+>
   State_print(s); fflush(stdout);
   
   op = Operator_cnot(3, controls, targets);
   op = Operator_compose2(op, Operator_swap(3,0,1));
   s = Operator_print_apply(op,s);
   Operator_free(op);
   
   controls[0] = 2;
   controls[1] = -1;
   targets[0] = 1;
   targets[1] = 0;
   targets[2] = -1;
   Operator op1 = Operator_cphase(3, targets);
   Operator op2 = Operator_cnot(3, controls, targets);
   Operator op3 = Operator_cphase(3, targets);
   Operator arr[4] = {op1, op2, op3, NULL};
   op = Operator_compose(arr);
   s = Operator_print_apply(op,s);
   Operator_free(op);
   
   State_free(s);
}



void Operator_run_tests(int n) {
   test_cnot (n);
   test_cphase (n);
   test_swap (n);
   test_pauli_X (n);
   test_pauli_Y (n);
   test_pauli_Z (n);
   test_hadamard (n);
   test_phase_S (n);
   test_phase_T (n);
   test_rot (n);
   test_multiply_add (n);
   test_is_unitary (n);
   test_is_hermitian (n);
   test_dagger (n);
   test_apply (n);
   test_tensor (n);
   test_compose (n);
   test_controlled (n);
   
   // // Printing Tests. Remove or comment out when finished testing.
   // Operator_print_tests();
   
   // // Algorithm tests. Remove or comment out when finished testing.
   // Operator_algorithm_tests();
   
}

int Operator_main (void) {
    srand(time(NULL));
    
    int n = 10;
    Operator_run_tests(n);
    return 0;
}